import { join } from 'path';
import { writeFile } from 'fs/promises';
import { nextOnPagesVersion } from '../utils';
import { getPhaseRoutes, getVercelConfig } from './getVercelConfig';

/**
 * Builds metadata files needed for the worker to correctly run.
 */
export async function buildMetadataFiles(
	outputDir: string,
	opts: BuildMetadataFilesOpts,
) {
	await Promise.all([
		buildNextStaticHeaders(outputDir),
		buildRoutes(outputDir, opts),
	]);
}

async function buildNextStaticHeaders(outputDir: string) {
	const vercelConfig = await getVercelConfig();

	const hitRoutes = getPhaseRoutes(vercelConfig.routes ?? [], 'hit');

	const nextStaticRoute = hitRoutes.find(
		route => route.src?.startsWith('/_next/static/'),
	);
	const nextStaticHeaders = (nextStaticRoute as VercelSource)?.headers;

	if (nextStaticHeaders) {
		await writeFile(
			join(outputDir, '_headers'),
			`
# === START AUTOGENERATED @cloudflare/next-on-pages IMMUTABLE HEADERS ===
/_next/static/*
${Object.entries(nextStaticHeaders)
	.map(([header, value]) => `  ${header}: ${value}`)
	.join('\n')}
# === END AUTOGENERATED @cloudflare/next-on-pages IMMUTABLE HEADERS ===\n`,
			{
				// in case someone configured redirects already, append to the end
				flag: 'a',
			},
		);
	}
}

async function buildRoutes(outputDir: string, opts: BuildMetadataFilesOpts) {
	const nextStaticPath = getNextStaticDirPath(opts);

	try {
		await writeFile(
			join(outputDir, '_routes.json'),
			JSON.stringify({
				version: 1,
				description: `Built with @cloudflare/next-on-pages@${nextOnPagesVersion}.`,
				include: ['/*'],
				exclude: [`${nextStaticPath}/*`],
			}),
			{ flag: 'ax' }, // don't generate file if it's already manually maintained
		);
	} catch (e) {
		if ((e as { code?: string }).code !== 'EEXIST') {
			throw e;
		}
	}
}

/**
 * Finds the path to the `/_next/static` directory from the list of static assets. Accounts for the
 * path being inside sub-directories, e.g. `/blog/_next/static`, and falls back to `/_next/static`.
 *
 * @param opts Options for building metadata files.
 * @returns The path to the `/_next/static` directory.
 */
function getNextStaticDirPath({
	staticAssets,
}: BuildMetadataFilesOpts): string {
	const regex = /^(.*\/_next\/static)\/.+$/;
	const asset = staticAssets.find(a => regex.test(a));
	return asset?.match(regex)?.[1] ?? '/_next/static';
}

type BuildMetadataFilesOpts = {
	staticAssets: string[];
};
