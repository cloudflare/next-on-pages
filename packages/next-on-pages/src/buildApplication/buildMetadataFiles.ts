import { join } from 'path';
import { writeFile } from 'fs/promises';
import { nextOnPagesVersion } from '../utils';
import { getPhaseRoutes, getVercelConfig } from './getVercelConfig';

/**
 * Builds metadata files needed for the worker to correctly run.
 */
export async function buildMetadataFiles(outputDir: string) {
	await Promise.all([
		buildNextStaticHeaders(outputDir),
		buildRoutes(outputDir),
	]);
}

async function buildNextStaticHeaders(outputDir: string) {
	const vercelConfig = await getVercelConfig();

	const hitRoutes = getPhaseRoutes(vercelConfig.routes ?? [], 'hit');

	const nextStaticRoute = hitRoutes.find(route =>
		route.src?.startsWith('/_next/static/')
	);
	const nextStaticHeaders = (nextStaticRoute as VercelSource)?.headers;

	if (nextStaticHeaders) {
		await writeFile(
			join(outputDir, '_headers'),
			`
# === START AUTOGENERATED @cloudflare/next-on-pages IMMUTABLE HEADERS ===
/_next/static/*
${Object.entries(nextStaticHeaders)
	.map(([header, value]) => `  ${header}: ${value}`)
	.join('\n')}
# === END AUTOGENERATED @cloudflare/next-on-pages IMMUTABLE HEADERS ===\n`,
			{
				// in case someone configured redirects already, append to the end
				flag: 'a',
			}
		);
	}
}

async function buildRoutes(outputDir: string) {
	try {
		await writeFile(
			join(outputDir, '_routes.json'),
			JSON.stringify({
				version: 1,
				description: `Built with @cloudflare/next-on-pages@${nextOnPagesVersion}.`,
				include: ['/*'],
				exclude: ['/_next/static/*'],
			}),
			{ flag: 'ax' } // don't generate file if it's already manually maintained
		);
	} catch (e) {
		if ((e as { code?: string }).code !== 'EEXIST') {
			throw e;
		}
	}
}
